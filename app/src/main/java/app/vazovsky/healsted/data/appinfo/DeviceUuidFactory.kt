package app.vazovsky.healsted.data.appinfo

import android.annotation.SuppressLint
import android.content.Context
import android.provider.Settings
import android.telephony.TelephonyManager
import dagger.hilt.android.qualifiers.ApplicationContext
import java.nio.charset.StandardCharsets
import java.util.*
import javax.inject.Inject

private const val PREFS_FILE = "device_id.xml"
private const val PREFS_DEVICE_ID = "device_id"

/**
 * Returns a unique UUID for the current android device. As with all UUIDs, this unique ID is "very highly likely"
 * to be unique across all Android devices. Much more so than ANDROID_ID is.
 * The UUID is generated by using ANDROID_ID as the base key if appropriate, falling back on
 * TelephonyManager.getDeviceID() if ANDROID_ID is known to be incorrect, and finally falling back on a random UUID
 * that's persisted to SharedPreferences if getDeviceID() does not return a usable value.
 * In some rare circumstances, this ID may change. In particular, if the device is factory reset a new device ID may
 * be generated. In addition, if a user upgrades their phone from certain buggy implementations of Android 2.2 to a
 * newer, non-buggy version of Android, the device ID may change. Or, if a user uninstalls your app on a device that
 * has neither a proper Android ID nor a Device ID, this ID may change on reinstallation.
 * Note that if the code falls back on using TelephonyManager.getDeviceId(), the resulting ID will NOT change after
 * a factory reset. Something to be aware of.
 * Works around a bug in Android 2.2 for many devices when using ANDROID_ID directly.
 *
 * @return a UUID that may be used to uniquely identify your device for most purposes.
 * @see "http://code.google.com/p/android/issues/detail?id=10603"
 */
class DeviceUuidFactory @Inject constructor(
    @ApplicationContext private val context: Context,
) {

    @Volatile var deviceUuid: UUID? = null

    init {
        if (deviceUuid == null) {
            synchronized(DeviceUuidFactory::class.java) {
                if (deviceUuid == null) {
                    val prefs = context.getSharedPreferences(PREFS_FILE, 0)
                    val id = prefs.getString(PREFS_DEVICE_ID, null)
                    if (id != null) {
                        // Use the ids previously computed and stored in the
                        // prefs file
                        deviceUuid = UUID.fromString(id)
                    } else {
                        @SuppressLint("HardwareIds")
                        val androidId = Settings.Secure.getString(
                            context.contentResolver,
                            Settings.Secure.ANDROID_ID
                        )
                        // Use the Android ID unless it's broken, in which case
                        // fallback on deviceId,
                        // unless it's not available, then fallback on a random
                        // number which we store to a prefs file
                        deviceUuid = if ("9774d56d682e549c" != androidId) {
                            UUID.nameUUIDFromBytes(androidId.toByteArray(StandardCharsets.UTF_8))
                        } else {
                            val deviceId = getDeviceId(context)

                            if (deviceId != null) {
                                UUID.nameUUIDFromBytes(deviceId.toByteArray(StandardCharsets.UTF_8))
                            } else {
                                UUID.randomUUID()
                            }
                        }
                        // Write the value out to the prefs file
                        prefs.edit().putString(PREFS_DEVICE_ID, deviceUuid.toString()).apply()
                    }
                }
            }
        }
    }

    @SuppressLint("HardwareIds", "MissingPermission")
    private fun getDeviceId(context: Context): String? {
        return try {
            (context.getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager).deviceId
        } catch (e: Exception) {
            null
        }
    }
}
